// mermaid_to_pdf.js
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import puppeteer from 'puppeteer';
import { fileURLToPath } from 'url';

// ES modules don't have __dirname, so we need to create it
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Récupérer les arguments de ligne de commande
const inputFile = process.argv[2] || 'diagrammes_cas_utilisation.md';
const outputFile = process.argv[3] || 'diagrammes_cas_utilisation.pdf';

console.log(`Fichier d'entrée: ${inputFile}`);
console.log(`Fichier de sortie: ${outputFile}`);

// Configuration
const inputMarkdown = path.join(__dirname, inputFile);
const outputDir = path.join(__dirname, 'temp_diagrams');
const outputPdf = path.join(__dirname, outputFile);

// Créer le dossier temporaire s'il n'existe pas
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Lire le contenu du fichier markdown
console.log(`Lecture du fichier markdown: ${inputMarkdown}`);
let markdownContent;
try {
  // Vérifie d'abord si le fichier existe
  if (!fs.existsSync(inputMarkdown)) {
    console.error(`Le fichier ${inputMarkdown} n'existe pas.`);
    process.exit(1);
  }
  
  // Lit le contenu avec un encodage explicite
  markdownContent = fs.readFileSync(inputMarkdown, {encoding: 'utf-8'});
  
  if (markdownContent.length === 0) {
    console.error(`Le fichier ${inputMarkdown} est vide.`);
    process.exit(1);
  }
  
  console.log(`Taille du fichier: ${markdownContent.length} caractères`);
  console.log(`Les 100 premiers caractères: ${markdownContent.substring(0, 100)}`);
  console.log("Recherche des blocs Mermaid...");

// Extraire les blocs mermaid - utiliser une expression régulière plus fiable pour les blocs Mermaid
const mermaidRegex = /```mermaid\s*([\s\S]*?)\s*```/g;
let match;
const mermaidBlocks = [];
let index = 0;

while ((match = mermaidRegex.exec(markdownContent)) !== null) {
  const mermaidContent = match[1].trim();
  const tempFile = path.join(outputDir, `diagram_${index}.mmd`);
  fs.writeFileSync(tempFile, mermaidContent);
  mermaidBlocks.push({
    content: mermaidContent,
    file: tempFile,
    outputImage: path.join(outputDir, `diagram_${index}.png`)
  });
  index++;
  console.log(`Diagramme ${index} extrait.`);
}

console.log(`Extraction de ${mermaidBlocks.length} diagrammes terminée.`);

// Convertir les diagrammes en images PNG
console.log('Conversion des diagrammes en images...');
mermaidBlocks.forEach((block, idx) => {
  try {
    execSync(`npx mmdc -i "${block.file}" -o "${block.outputImage}" -b white`, { stdio: 'inherit' });
    console.log(`Diagramme ${idx+1}/${mermaidBlocks.length} converti.`);
  } catch (error) {
    console.error(`Erreur lors de la conversion du diagramme ${idx}:`, error);
  }
});

// Créer le HTML avec les images
const sections = markdownContent.split('```mermaid');
let htmlContent = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Diagrammes de Cas d'Utilisation CesiZen</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1, h2 { color: #333; }
    img { max-width: 100%; height: auto; margin: 20px 0; }
    .page-break { page-break-before: always; }
  </style>
</head>
<body>
  <h1>Diagrammes de Cas d'Utilisation CesiZen</h1>
`;

// Ajouter le texte du début (jusqu'au premier diagramme)
htmlContent += sections[0].replace(/^# (.*)$/m, '').replace(/\n## /g, '\n<h2>').replace(/\n(?=\w)/g, '\n<p>').replace(/\n$/g, '</p>\n');

// Ajouter chaque section avec son image
for (let i = 1; i < sections.length; i++) {
  const sectionParts = sections[i].split('```');
  const afterDiagram = sectionParts[1];
  
  // Ajouter une page break avant chaque nouvelle section sauf la première
  if (i > 1) {
    htmlContent += '<div class="page-break"></div>\n';
  }
    // Ajouter l'image du diagramme avec chemin absolu
  htmlContent += `<img src="file:///${mermaidBlocks[i-1].outputImage.replace(/\\/g, '/')}" alt="Diagramme ${i}" />\n`;
  
  // Ajouter le texte qui suit jusqu'au prochain diagramme
  if (afterDiagram) {
    htmlContent += afterDiagram.replace(/\n## /g, '\n<h2>').replace(/\n(?=\w)/g, '\n<p>').replace(/\n$/g, '</p>\n');
  }
}

htmlContent += '</body></html>';

// Écrire le fichier HTML temporaire
const htmlFile = path.join(outputDir, 'output.html');
fs.writeFileSync(htmlFile, htmlContent);

// Convertir le HTML en PDF avec Puppeteer
console.log('Conversion du HTML en PDF...');
(async () => {
  try {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(`file://${htmlFile}`, { waitUntil: 'networkidle0' });
    await page.pdf({ 
      path: outputPdf, 
      format: 'A4',
      margin: { top: '1cm', right: '1cm', bottom: '1cm', left: '1cm' },
      printBackground: true
    });
    await browser.close();
    console.log(`PDF généré avec succès : ${outputPdf}`);
  } catch (error) {
    console.error('Erreur lors de la génération du PDF:', error);
  }
})();
